from typing import List, Dict, Any
from .data_structures import TaskSpec, CandidateProgram
from .strategy_interface import Strategy
import time
import traceback # Import traceback for better error logging

class StrategyRegistry:
    """Holds registered strategy instances."""
    def __init__(self):
        self._strategies: Dict[str, Strategy] = {}
        print("Initialized StrategyRegistry.")

    def register(self, strategy: Strategy):
        """Registers a strategy instance."""
        if strategy.strategy_id in self._strategies:
            print(f"Warning: Strategy with ID '{strategy.strategy_id}' already registered. Overwriting.")
        self._strategies[strategy.strategy_id] = strategy
        print(f"Registered strategy: {strategy.strategy_id}")

    def get_strategy(self, strategy_id: str) -> Strategy:
        """Gets a strategy instance by ID."""
        strategy = self._strategies.get(strategy_id)
        if not strategy:
            raise ValueError(f"Strategy with ID '{strategy_id}' not found.")
        return strategy

    def get_all_strategies(self) -> List[Strategy]:
        """Gets a list of all registered strategy instances."""
        return list(self._strategies.values())

    def setup_all(self):
        """Calls setup() on all registered strategies."""
        print("Setting up all registered strategies...")
        for strategy_id, strategy in self._strategies.items():
            try:
                strategy.setup()
            except Exception as e:
                print(f"Error setting up strategy {strategy_id}: {e}\n{traceback.format_exc()}")
        print("Finished setting up strategies.")

    def teardown_all(self):
        """Calls teardown() on all registered strategies."""
        print("Tearing down all registered strategies...")
        for strategy_id, strategy in self._strategies.items():
            try:
                strategy.teardown()
            except Exception as e:
                print(f"Error tearing down strategy {strategy_id}: {e}\n{traceback.format_exc()}")
        print("Finished tearing down strategies.")


class SimpleDispatcher:
    """
    MVP Dispatcher: Runs all registered strategies sequentially.
    """
    def __init__(self, registry: StrategyRegistry):
        self.registry = registry
        print("Initialized SimpleDispatcher.")

    def run(self, task_spec: TaskSpec, features: Dict[str, Any]) -> List[CandidateProgram]:
        """
        Runs the 'generate' method of all registered strategies.

        Args:
            task_spec: The TaskSpec object.
            features: Extracted features for the task.

        Returns:
            A list containing all CandidatePrograms generated by all strategies.
        """
        all_candidates: List[CandidateProgram] = []
        strategies = self.registry.get_all_strategies()
        print(f"Dispatching task '{task_spec.task_id}' to {len(strategies)} strategies...")

        for strategy in strategies:
            strategy_id = strategy.strategy_id
            print(f"--- Running Strategy: {strategy_id} ---")
            start_time = time.time()
            try:
                candidates = strategy.generate(task_spec, features)
                duration = time.time() - start_time
                print(f"Strategy {strategy_id} generated {len(candidates)} candidates in {duration:.2f}s.")
                all_candidates.extend(candidates)
            except Exception as e:
                duration = time.time() - start_time
                print(f"Strategy {strategy_id} failed after {duration:.2f}s: {e}\n{traceback.format_exc()}")
                # Optionally create a placeholder CandidateProgram indicating the error
            print(f"--- Finished Strategy: {strategy_id} ---")

        print(f"Dispatcher finished. Total candidates generated: {len(all_candidates)}")
        return all_candidates 