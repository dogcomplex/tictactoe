from typing import List, Dict, Any
from .data_structures import TaskSpec, CandidateProgram
from .strategy_interface import Strategy
from .strategy_registry import StrategyRegistry # Import from correct module
import time
import traceback # Import traceback for better error logging
import logging # Use logging instead of print

logger = logging.getLogger(__name__)

class Dispatcher: # Renamed from SimpleDispatcher
    """
    MVP Dispatcher: Runs all registered strategies sequentially.
    """
    def __init__(self, registry: StrategyRegistry):
        self.registry = registry
        logger.info("Initialized Dispatcher.") # Use logger

    def dispatch(self, task_spec: TaskSpec, features: Dict[str, Any]) -> List[CandidateProgram]: # Renamed from run
        """
        Runs the 'generate' method of all registered strategies.

        Args:
            task_spec: The TaskSpec object.
            features: Extracted features for the task.

        Returns:
            A list containing all CandidatePrograms generated by all strategies.
        """
        all_candidates: List[CandidateProgram] = []
        # Correctly get dictionary from StrategyRegistry
        strategies_dict = self.registry.get_all_strategies()
        logger.info(f"Dispatching task '{task_spec.task_id}' to {len(strategies_dict)} strategies...")

        # Iterate through the dictionary
        for strategy_id, strategy in strategies_dict.items():
            logger.info(f"--- Running Strategy: {strategy_id} ---")
            start_time = time.time()
            try:
                candidates = strategy.generate(task_spec, features)
                duration = time.time() - start_time
                logger.info(f"Strategy {strategy_id} generated {len(candidates)} candidates in {duration:.2f}s.")
                all_candidates.extend(candidates)
            except Exception as e:
                duration = time.time() - start_time
                # Use logger for errors
                logger.error(f"Strategy {strategy_id} failed after {duration:.2f}s: {e}", exc_info=True)
                # Optionally create a placeholder CandidateProgram indicating the error
            logger.info(f"--- Finished Strategy: {strategy_id} ---")

        logger.info(f"Dispatcher finished. Total candidates generated: {len(all_candidates)}")
        return all_candidates 