import json
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Union
from enum import Enum

# R-MVP-01: Standard Task Definition
@dataclass
class TaskSpec:
    """
    Standard representation for a reasoning task specification.

    Corresponds to the following JSON structure:
    {
        "task_id": "unique_task_identifier",
        "description": "Optional natural language description.",
        "inputs": [ {"input_name1": value1, "input_name2": value2}, ... ],
        "outputs": [ {"output_name1": value1, ...}, ... ],
        "constraints": ["constraint1", "constraint2", ...],
        "metadata": { "key": "value", ... }
    }
    Constraints and metadata are optional.
    Number of entries in 'inputs' and 'outputs' must match.
    """
    task_id: str
    description: Optional[str] = None
    inputs: List[Dict[str, Any]] = field(default_factory=list)
    outputs: List[Dict[str, Any]] = field(default_factory=list)
    constraints: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def __post_init__(self):
        if len(self.inputs) != len(self.outputs):
            raise ValueError("Number of inputs and outputs must match.")
        if not self.task_id:
            raise ValueError("task_id cannot be empty.")

    @classmethod
    def from_json_file(cls, file_path: str) -> 'TaskSpec':
        with open(file_path, 'r') as f:
            data = json.load(f)
        return cls(**data)

    @classmethod
    def from_json_string(cls, json_string: str) -> 'TaskSpec':
        data = json.loads(json_string)
        return cls(**data)

    def to_json(self, indent=2) -> str:
        # Convert dataclass to dict first for json serialization
        return json.dumps(self.__dict__, indent=indent)

# R-MVP-04: Standard Program/Hypothesis Representation
class VerificationStatus(Enum):
    NOT_VERIFIED = "Not Verified"
    CONSISTENT = "Consistent" # Passes all examples
    CONTRADICTED = "Contradicted" # Fails one or more examples
    ERROR = "Verification Error"

@dataclass
class CandidateProgram:
    """
    Standard representation for a candidate program or hypothesis
    generated by a reasoning strategy.
    """
    program_representation: Union[str, Dict, Any] # The core rule/program (e.g., CNF string, tensor rule dict, code string)
    representation_type: str # Identifier for the type (e.g., 'CNF', 'TensorRule', 'PythonCode')
    source_strategy: str # Identifier of the strategy that generated this
    confidence: Optional[float] = None # Strategy's confidence (0.0 to 1.0)
    verification_status: VerificationStatus = VerificationStatus.NOT_VERIFIED
    provenance: Dict[str, Any] = field(default_factory=dict) # Metadata: features used, source version, etc.
    verification_results: Optional[Dict] = None # Detailed results from verifier

# Structure for Verification Results (Used by R-MVP-09)
@dataclass
class VerificationResult:
    """Holds the outcome of verifying a CandidateProgram against a TaskSpec."""
    overall_status: VerificationStatus
    details: List[Dict[str, Any]] = field(default_factory=list) # Per-example pass/fail info
    error_message: Optional[str] = None 